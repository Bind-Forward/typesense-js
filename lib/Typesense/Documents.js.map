{"version":3,"sources":["Typesense/Documents.js"],"names":["RESOURCEPATH","Documents","collectionName","apiCall","_collectionName","_apiCall","document","post","_endpointPath","mode","documents","options","logger","warn","documentsInJSONLFormat","map","JSON","stringify","join","import","resultsInJSONLFormat","split","r","parse","Array","isArray","performRequest","queryParameters","bodyParameters","additionalHeaders","get","searchParameters","operation","Collections","undefined"],"mappings":"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","sourcesContent":["'use strict'\n\nimport Collections from './Collections'\n\nconst RESOURCEPATH = '/documents'\n\nexport default class Documents {\n  constructor (collectionName, apiCall) {\n    this._collectionName = collectionName\n    this._apiCall = apiCall\n  }\n\n  create (document) {\n    return this._apiCall.post(this._endpointPath(), document)\n  }\n\n  upsert (document) {\n    return this._apiCall.post(this._endpointPath(), document, {mode: 'upsert'})\n  }\n\n  update (document) {\n    return this._apiCall.post(this._endpointPath(), document, {mode: 'update'})\n  }\n\n  async createMany (documents, options = {}) {\n    this._apiCall.logger.warn('createMany is deprecated and will be removed in a future version. Use import instead, which now takes both an array of documents or a JSONL string of documents')\n    let documentsInJSONLFormat = documents.map(document => JSON.stringify(document)).join('\\n')\n    let resultsInJSONLFormat = await this.import(documentsInJSONLFormat, options)\n    return resultsInJSONLFormat.split('\\n').map(r => JSON.parse((r)))\n  }\n\n  /**\n   * Import a set of documents in a batch.\n   * @param {string|Array} documents - Can be a JSONL string of documents or an array of document objects.\n   * @return {string|Array} Returns a JSONL string if the input was a JSONL string, otherwise it returns an array of results.\n   */\n  async import (documents, options = {}) {\n    let documentsInJSONLFormat\n    if (Array.isArray(documents)) {\n      documentsInJSONLFormat = documents.map(document => JSON.stringify(document)).join('\\n')\n    } else {\n      documentsInJSONLFormat = documents\n    }\n\n    const resultsInJSONLFormat = await this._apiCall.performRequest(\n      'post',\n      this._endpointPath('import'),\n      {\n        queryParameters: options,\n        bodyParameters: documentsInJSONLFormat,\n        additionalHeaders: {'Content-Type': 'text/plain'}\n      }\n    )\n\n    if (Array.isArray(documents)) {\n      return resultsInJSONLFormat.split('\\n').map(r => JSON.parse((r)))\n    } else {\n      return resultsInJSONLFormat\n    }\n  }\n\n  export () {\n    return this._apiCall.get(this._endpointPath('export'))\n  }\n\n  search (searchParameters) {\n    return this._apiCall.get(this._endpointPath('search'), searchParameters)\n  }\n\n  _endpointPath (operation) {\n    return `${Collections.RESOURCEPATH}/${this._collectionName}${Documents.RESOURCEPATH}${operation === undefined ? '' : '/' + operation}`\n  }\n\n  static get RESOURCEPATH () {\n    return RESOURCEPATH\n  }\n}\n"],"file":"Documents.js"}